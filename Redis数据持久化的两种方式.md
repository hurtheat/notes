#### 一、AOF(append only file)

###### 1.AOF的概念

    AOF全称Append Only File，只追加文件方式。当Redis增删改查数据后，将其命令写入一个日志中，如Redis遭遇宕机，可以根据这个日志文件进行数据的恢复，达到数据持久化的目的。

###### 2.AOF的性质--写后日志

    AOF是一个写后日志，也就是说当数据在Redis操作后，如果成功，则将这些操作数据的命令追加的这个日志文件中。

    写后日志的原因：

- Redis是单线程，如果先写追加后操作数据，会阻塞数据的操作	
- redis追加日志时不会进行语法校验，如果先追加不能保证追加进日志的命令的正确。

###### 3.AOF存在的问题

- 当操作数据成功后，准备将数据追加到日志中时，此时Redis宕机，那么这样操作这部分数据的命令没有追加进入日志，下次恢复的时候就无法找到这部分数据，造成数据不一致。
- 当数据恢复的时候，Redis必须一条条读取AOF日志中的命令，逐条恢复，如果数据量大，恢复的时间较长。
- AOF日志最终是存在于磁盘中的，意味这这些日志都要写回磁盘中，写回的这一过程想到较慢（物理磁盘），可能会阻塞下一次的主线程的数据操作，造成Redis响应变慢。
- 既然AOF是以日志文件的形式存储命令，那么如果数据过大，文件也会很大，造成存储空间的压力（一般不会，只是潜在问题）。

###### 4.写回策略

    针对上述日志没有记录到日志文件中，Redis宕机以及写回磁盘数据阻塞主线程的下一次操作的问题，可以发现其实都是日志写回磁盘的时机问题。
如果写回太频繁，对于Redis的性能有影响，不够频繁，造成数据不一致的几率又更高了。
因此，Redis提供了三种常用的写回策略

1. **Always**：同步写回，每个命令写完，立即同步到磁盘
2. **EverySec**:每隔一秒写回磁盘一次
3. **NO**:Redis不控制写回时间，又操作系统决定

###### 5.AOF的重写机制

- **重写机制产生的原因：**

​		我们知道，AOF的日志文件越来越大，就可能会造成恢复过慢以及超过操作系统对文件大小的限制。为了解决这个问题，Redis就产	生了**AOF的重写机制**。所以重写解决的问题就是日志文件过大的问题。

- **重写机制的实现：**

​		重写最核心的就是**多变一**，将原用的多个指令变成一个，以达到减少日志文件的目的。试想，AOF对同一个key进行操作的时候，是会产生多个操作指令存入AOF日志文件的，但是这些中间的指令就造成了文件过大，如果我们把最终这个key以set记录下来，是不是就剩下其他中间指令的的空间，这样让达到了缩小AOF日志文件的作用。

​		重写是主线程fork出一个bgrewriteaof 子进程，这个子进程会拷贝内存中页表，和主进程一样，通过这个页表就可以找到内存中的地址，所以**子进程可以再不阻塞主线程的前提下**将数据的写入命令写入**重写日志**。

- 注意事项

  1. 因为主线程没有阻塞，依旧可以处理新的操作，此时，若有写操作，Redis依旧会把这个记录放在内存AOF缓冲中，等待写回机制写的磁盘中，同时也这个操作也会记录在内存重写缓冲区中，也是等待时机写回磁盘中的AOF重写日志。所以，**重写日志和AOF是两个不同文件**。

  2. **AOF是不会阻塞主线程的**，但是不绝对。原因如下：

     - 因为fork操作是在主线程中执行的，这时候主线程需要拷贝内存页表，这个页表记录了虚拟内存和物理内存的映射关系，如果内存很大，拷贝过程花费的时间就会很大，而这个拷贝过程中主线程是阻塞的。
     - fork完成后，主线程和bgrewriteaof子进程使用的是同一块儿内存空间，这时如果有写操作进来，且是操作已有的key,那么为了保证数据的最新，会才有**写时复制的方式（CopyOnWrite）**，为这个key申请新空间，进行写操作，原先的变成副本，如果这个key是bigkey，那么耗时也会很多。

  3. 在redis.conf中有俩个配置启动重写：

     ```java
     auto-aof-rewrite-percentage 100 #AOF文件大小较上次重写超过100%时进行重写
     auto-aof-rewrite-min-size 64mb #aof文件大小超过64m时重写
     ```

     
